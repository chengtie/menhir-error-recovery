(**

   This module demonstrates that a lexer generated by ocamllex can be
   turned into a functional lexer, simply by memoizing all the
   encountered tokens and by seeing a lexer as a projection of these
   tokens.

*)

open Parser
open Parser.MenhirInterpreter

type ptoken = token * Lexing.position * Lexing.position

module LexerF : sig
  type t = int
  val initialize : Lexing.lexbuf -> unit
  val start : t
  val next  : t -> ptoken * t
  val prev  : t -> ptoken * t 
  val get   : t -> ptoken
  val get'  : t -> token
  val current_position : t -> Position.t
  val skip_until_before : (token -> bool) -> t -> t
  val print_state : unit -> unit
end = struct

  (* a reverse order of tokens *)
  let buffer =
    ref []

  (* like length *)
  let size =
    ref 0

  let print_state () =
    Printf.printf "size: %d    " !size;
    Printf.printf "buffer: ";
    List.iter (fun (x, _, _) -> Printf.printf "%s " (Symbol.string_of_token x)) !buffer;
    Printf.printf "\n"
  
  let more = ref (fun () -> assert false)

  let initialize (lexbuf: Lexing.lexbuf) =
    (* A token supplier is a function of no arguments which delivers a new token (together with its start and end positions) every time it is called. *)
    (* The function lexer_lexbuf_to_supplier, applied to a lexer and to a lexing buffer, produces a fresh supplier. *)
    more := ((lexer_lexbuf_to_supplier (Lexer.token: Lexing.lexbuf -> token) lexbuf) : supplier)

  type t = int

  let start = 0

  (* [pos] starts from 1, rather than 0. 
    (get 1) returns the first token *)
  let get pos =
    List.nth !buffer (!size - pos)

  let token_of_ptoken (p, _, _) = p

  let current_position_of_ptoken (_, start, stop) =
    Position.lex_join start stop

  let current_position pos =
    current_position_of_ptoken (get pos)

  let get' pos =
    token_of_ptoken (get pos)

  let next pos =
    if pos >= !size - 1 then (
      buffer := !more () :: !buffer;
      incr size;
    );
    let pos = pos + 1 in
    (get pos, pos)

  let prev pos =
    if pos <= 0 
      then failwith "impossible to get the token even before the 0th token, pureLexer.ml"
    else if pos = 1 then
      (* there is no token before the first token; the ptoken value here is not significant *)
      (get pos, 0) 
    else
      let pos = pos - 1 in
      (get pos, pos)

  let skip_until_before pred pos =
    let rec aux pos =
      let token, _, _ = get pos in
      if token = EOF then pos
      else if pred token then pos - 1
      else aux (snd (next pos))
    in
    aux pos

end
